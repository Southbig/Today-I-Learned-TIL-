도커라이징(Dockerizing)은, 애플리케이션을 도커 컨테이너에서 돌릴 수 있도록 이미지로 만드는 과정을 의미한다
도커라이징이라는 말보다는 컨테이너화 라는 말이 훨씬 많이 쓴다

# 컨테이너화란?

**컨테이너화란 소프트웨어 코드를 라이브러리, 프레임워크 및 기타 종속성과 같은 필수 요소와 함께 패키지에 포함하여 각자의 "컨테이너"로 분리하는 것을 뜻한다**

이렇게 **컨테이너화된 소프트웨어 또는 애플리케이션** 은 어떤 환경과 인프라에서든 해당 **환경이나 인프라의 운영 체제와는 상관없이 이동할 수 있으며 일관성있게 실행된다**
즉, 컨테이너는 애플리케이션을 둘러싼 일종의 버블 또는 컴퓨팅 공간으로,
**그 주위와 분리해주는 역할을 하는 것이다**
기본적으로 완전한 기능을 갖춘 이식성이 있는 컴퓨팅 환경이다

컨테이너는 하나의 플랫폼 또는 운영 체제에서 코드를 작성하는 방식을 대체한다
이러한 방식은 해당 코드가 새로운 환경과 호환되지 않을 경우 애플리케이션의 이동을 어렵게
만드는 원인이었으며 수정이 필요한 버그, 오류, 결함 등이 생겼다
이렇게 되면 시간은 더 많이 소요되고, 생산성은 줄어들며, 사기도 꺾이게 된다

플랫폼과 인프라 전반에서 이동이 가능한 컨테이너로 애플리케이션을 패키징하는 경우 해당 애플리케이션을 어디에서든 사용할 수 있다
실행하는 데 필요한 요소는 이미 패키지 안에 모두 포함되어 있기 때문이다

프로세스를 분리하는 아이디어는 수년간 존재했지만,
2013년 Docker가 Docker Engine을 소개하면서 비로소 개발자가 사용하기 쉬운 툴을 갖춘 컨테이너 사용의 기준이 정해졌고 패키징에 대한 범용적 접근 방식이 제시되었다
그러면서 컨테이너 기술 도입이 가속화되었으며, 오늘날 개발자는 Docker가 개척한 Open Container Initiative 표준을 지원하는 다양한 컨테이너화 플랫폼과 툴을 선택할 수 있다

## 이점

컨테이너의 특성인 "경량화"와 이식성은 호스트 머신의 운영 체제 커널을 공유할 수 있기 때문이다
각 컨테이너에는 개별 운영 체제가 필요하지 않으며 애플리케이션은 베어 메탈, 클라우드, 가상 머신(VM)까지 어떤 인프라에서도 동일하게 실행된다

이와 유사하게, 개발자는 하나의 호스트 환경에서 동일한 툴을 사용해 컨테이너 작업을 수행할 수 있으므로 운영 체제 전반에서 컨테이너화된 애플리케이션의 개발과 배포가 훨씬 간단해진다

## 컨테이너와 가상 머신 비교

가상 머신(VM)은 자체 CPU, 메모리, 네트워크 인터페이스, 스토리지가 있는 가상 컴퓨터 시스템처럼 기능하는 가상 환경으로, 물리적 하드웨어 시스템에 생성된다(오프프레미스 또는 온프레미스에 위치)

애플리케이션이 여러 환경에서 작동할 수 있도록 애플리케이션의 완전한 분리를 허용한다는 점에서 컨테이너화와 가상화는 유사하다
**이 둘의 가장 큰 차이점은 그 규모와 이식성에 있다**

VM은 일반적으로 기가바이트로 측정되기 때문에 그 규모가 가상화에 비해 크며, 자체 OS를 포함하고 있기 때문에 여러 가지 리소스 집약적인 기능을 한 번에 수행할 수 있다
VM에서 사용할 수 있는 리소스가 늘어남에 따라 전체 서버, OS, 데스크톱, 데이터베이스, 네트워크를 추상화, 분할, 복제, 에뮬레이션할 수 있다

컨테이너는 일반적으로 그 규모가 훨씬 작은 메가바이트로 측정되며, 애플리케이션 및 실행 환경보다 큰 것은 패키징하지 않는다

**VM은 전통적인 모놀리식 IT 아키텍처에 적합** 하지만,
**컨테이너는 클라우드, CI/CD, DevOps와 같은 새로운 이머징 기술과 호환된다**

## 컨테이너와 마이크로서비스 비교

컨테이너는 마이크로서비스라고 알려진 특정 태스크를 수행하는 단일 기능을 패키지하는 데 사용되는 경우가 많다
마이크로서비스는 애플리케이션을 더 작고, 특화된 서비스로 분할한 것이다
이를 통해 개발자는 애플리케이션의 전체적인 성능에는 아무런 영향을 주지 않으면서 애플리케이션의 특정 영역에 대한 작업에 집중할 수 있다

업데이트하거나 문제를 수정하는 중에도 애플리케이션을 계속 실행할 수 있으므로 더 빠른 개선, 테스트, 배포가 가능하다

컨테이너 내의 마이크로서비스는 컨테이너의 이식성, 호환성, 확장성을 모두 갖추고 있기 때문에 마이크로서비스와 컨테이너는 서로 원활하게 연동된다

## 컨테이너 오케스트레이션

그럼 이 모든 컨테이너를 어떻게 관리해야 할까?
컨테이너 오케스트레이션을 구현하면 간단하다
컨테이너 오케스트레이션은 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화한다

쿠버네티스는 분산화되고 컨테이너화된 애플리케이션을 대규모로 관리하도록 돕는 오픈소스 컨테이너 오케스트레이션 플랫폼이다
소프트웨어를 실행하고자 하는 환경에서 쿠버네티스를 활용하면 플랫폼이 컨테이너를 배포하고 관리하는 데 필요한 거의 모든 작업을 처리한다

쿠버네티스는 Linux 컨테이너 기술의 초기 기여자이기도 한 Google의 엔지니어 팀에서 처음으로 개발하고 설계했으며, 2015년에 CNCF(Cloud Native Computing Foundation)에 기부되었다
따라서 쿠버네티스 커뮤니티를 유지 관리할 책임은 전적으로 CNCF에 있으며 자발적으로 참여하는 기여자 및 관리자가 쿠버네티스 개발, 유지 관리, 릴리스를 맡고 있다

Red Hat은 쿠버네티스가 출시되기 전부터 Google과 함께 쿠버네티스 개발에 참여한 최초 기업 중 하나이며, 쿠버네티스 프로젝트에서 두 번째 주요 기여자가 되었다

[Red Hat, 컴터이너화란 ?](https://www.redhat.com/ko/topics/cloud-native-apps/what-is-containerization)

# Node.js 웹 앱의 도커라이징

이 예제에서는 Node.js 애플리케이션을 Docker 컨테이너에 넣는 방법을 보여준다
이 가이드는 개발 목적이지 프로덕션 배포용이 아니다
Docker가 설치되어 있고 Node.js 애플리케이션의 구조에 대한 기본적인 지식이 있어야 한다

먼저 간단한 Node.js 웹 애플리케이션을 만든 후에 이 애플리케이션을 위한 Docker 이미지를 만들어서 컨테이너로 실행할 것이다

Docker를 사용하면 애플리케이션과 모든 의존성을 소프트웨어 개발에서 컨테이너라고 부르는 표준화된 단위로 패키징할 수 있다
컨테이너는 리눅스 운영체제의 간단 버전이며, 이미지는 컨테이너에 로드하는 소프트웨어를 말한다

# Node.js 앱 생성

우선, 모든 파일을 넣은 새로운 디렉터리를 만들자
이 디렉터리 안에 애플리케이션과 의존성을 알려주는 package.json 파일을 생성하자

```
{
  "name": "docker_web_app",
  "version": "1.0.0",
  "description": "Node.js on Docker",
  "author": "First Last <first.last@example.com>",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.16.1"
  }
}
```

package.json 파일을 만든 후, npm install을 실행하고, 버전 5 이상의 npm을 사용한다면, Docker 이미지에 복사할 package-lock.json 파일을 npm에서 생성할 것이다

이제 Express.js 프레임워크로 웹앱을 정의하는 server.js를 만들자

```
'use strict';

const express = require('express');

// 상수
const PORT = 8080;
const HOST = '0.0.0.0';

// 앱
const app = express();
app.get('/', (req, res) => {
  res.send('Hello World');
});

app.listen(PORT, HOST);
console.log(`Running on http://${HOST}:${PORT}`);
```

다음 단계에서 공식 Docker 이미지를 사용해서 Docker 컨테이너 안에서 이 앱을 실행하는 방법을 살펴보자
먼저 앱의 Docker 이미지를 만들어야 한다

# Dockerfile 생성

Dockerfile이라는 빈 파일을 생성

> touch Dockerfile

선호하는 텍스트 에디터로 Dockerfile을 연다

가장 먼저 해야 할 것은 어떤 이미지를 사용해서 빌드할 것인지를 정의하는 것이다
여기서는 Docker Hub에 있는 node의 최신 LTS(장기 지원) 버전인 12을 사용할 것이다

> FROM node:12

다음으로 이미지 안에 애플리케이션 코드를 넣기 위해 디렉터리를 생성할 것이다
이 디렉터리가 애플리케이션의 작업 디렉터리가 된다

> `# 앱 디렉터리 생성`
> WORKDIR /usr/src/app

이 이미지에는 이미 Node.js와 NPM이 설치되어 있으므로 npm 바이너리로 앱의 의존성을 설치하기만 하면 된다

버전 4 이하의 npm은 package-lock.json 파일을 생성하지 않을 것이다

> `# 앱 의존성 설치` >`# 가능한 경우(npm@5+) package.json과 package-lock.json을 모두 복사하기 위해` >`# 와일드카드를 사용`
> COPY package\*.json ./
>
> RUN npm install
> `# 프로덕션을 위한 코드를 빌드하는 경우` >`# RUN npm ci --only=production`

작업 디렉터리 전체가 아닌 package.json 파일만을 복사하고 있는데, 이는 캐시된 Docker 레이어의 장점을 활용하기 위함이다
bitJudo가 이에 대해 여기에 잘 설명해 두었다
추가로, 주석에 언급된 npm ci 커맨드는 프로덕션 환경을 위한 더 빠르고, 신뢰할 수 있고, 재현 가능한 빌드를 제공한다

Docker 이미지 안에 앱의 소스코드를 넣기 위해 COPY 지시어를 사용한다

> `# 앱 소스 추가`
> COPY . .

앱이 8080포트에 바인딩 되어 있으므로 EXPOSE 지시어를 사용해서 docker 데몬에 매핑한다

> EXPOSE 8080

마지막으로 런타임을 정의하는 CMD로 앱을 실행하는 중요 명령어를 정의해야 한다
여기서는 서버를 구동하도록 node server.js을 실행하는 기본 npm start을 사용할 것이다

> CMD [ "node", "server.js" ]

Dockerfile은 다음과 같아야 한다

> **FROM node:12**
>
> `# 앱 디렉터리 생성` >**WORKDIR /usr/src/app**
>
> `# 앱 의존성 설치` >`# 가능한 경우(npm@5+) package.json과 package-lock.json을 모두 복사하기 위해` >`# 와일드카드를 사용`
> C**OPY package\*.json ./**
>
> **RUN npm install** >`# 프로덕션을 위한 코드를 빌드하는 경우` >`# RUN npm ci --only=production`

> `# 앱 소스 추가` >**COPY . .**

> **EXPOSE 8080** >**CMD [ "node", "server.js" ]**

# .dockerignore 파일

Dockerfile과 같은 디렉터리에 .dockerignore 파일을 다음 내용으로 만들어보자

> node_modules
> npm-debug.log

이는 Docker 이미지에 로컬 모듈과 디버깅 로그를 복사하는 것을 막아서 이미지 내에서 설치한 모듈을 덮어쓰지 않게 한다

# 이미지 빌드

작성한 Dockerfile이 있는 디렉터리로 가서 Docker 이미지를 빌드하는 다음 명령어를 실행한다
`-t` 플래그로 이미지에 태그를 추가할 수 있어 나중에 docker images 명령어로 쉽게 찾을 수 있다

> **docker build . -t <your username>/node-web-app**

Docker가 당신이 빌드한 이미지를 보여줄 것이다

> $ **docker images**
>
> `# 예시` >**REPOSITORY TAG ID CREATED** >**node 12 1934b0b038d1 5 days ago** >**<your username>/node-web-app latest d64d3505b0d2 1 minute ago**

# 이미지 실행

-d로 이미지를 실행하면 분리 모드로 컨테이너를 실행해서 백그라운드에서 컨테이너가 돌아가도록 한다
-p 플래그는 공개 포트를 컨테이너 내의 비공개 포트로 리다이렉트한다
앞에서 만든 이미지를 실행하자

> **docker run -p 49160:8080 -d <your username>/node-web-app**

앱의 로그를 출력

> `# 컨테이너 아이디를 확인합니다` >**$ docker ps**
>
> `# 앱 로그를 출력합니다` >**$ docker logs <container id>**
>
> `# 예시`
> Running on http://localhost:8080

컨테이너 안에 들어가 봐야 한다면 exec 명령어를 사용할 수 있다

> `# 컨테이너에 들어갑니다`
> $ **docker exec -it <container id> /bin/bash**

# 테스트

앱을 테스트하려면 Docker 매핑된 앱 포트를 확인

> $ **docker ps**
>
> `# 예시` >**ID IMAGE COMMAND ... PORTS** >**ecce33b30ebf <your username>/node-web-app:latest npm start ... 49160->8080**

위 예시에서 Docker가 컨테이너 내의 8080 포트를 머신의 49160 포트로 매핑했다

이제 curl로 앱을 호출할 수 있다(필요하다면 sudo apt-get install curl로 설치한다)

> $ **curl -i localhost:49160**
>
> HTTP/1.1 200 OK
> X-Powered-By: Express
> Content-Type: text/html; charset=utf-8
> Content-Length: 12
> ETag: W/"c-M6tWOb/Y57lesdjQuHeB1P/qTV0"
> Date: Mon, 13 Nov 2017 20:53:59 GMT
> Connection: keep-alive
>
> Hello world
