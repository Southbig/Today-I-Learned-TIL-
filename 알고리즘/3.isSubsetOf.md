# naive solution

**O(N^2)**

```
const isSubsetOf = function (base, sample) {
  let result = []
  for (let i = 0; i < sample.length; i++) {
    for (let j = 0; j < base.length; j++) {
      if (sample[i] === base[j]) {
        result.push(true)
      }
    }
  }
  if (sample.length === result.length) {
    return true;
  }
  else {
    return false;
  }
};
```

**반복문**
반복문으로 base를 순회한다
반복문으로 sample를 순회한다
sample의 모든 요소중 base에 있다면 요소를 true로 바꾸고 없다면 false로 바꾼다
최종 반복문을 통하여 같은 요소가 있다면 result 에 true를 넣어준다
sample의 요소의 길이와 result의 요소의 길이가 같으면 true
같지 않다면 false
**시간초과**

# naive solution 2

**O(M \* N)**

```
const isSubsetOf = function (base, sample) {
  return sample.every((item) => base.includes(item));
}
```

재귀를 통해 ON으로 바꿔보자

# naive solution 2

**재귀함수**

**O(N\*M)**

```
const isSubsetOf = function (base, sample) {

  let result = []

  let trueOrFalse = (base, sample) => {
    for (let i = 0; i < base.length; i++) {
      if (base[i] === sample) {
        result.push(true);
        break;
      }
    }
    return result;
  }

  for (let i = 0; i < sample.length; i++) {
    let comparingValue = sample[i];
    result = trueOrFalse(base, comparingValue);
  }
  return result.length === sample.length;
};
```

**실행초과**

O(N\*logN)에 대하여 생각해보자
